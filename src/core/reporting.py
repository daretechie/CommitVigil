# Copyright (c) 2026 CommitVigil AI. All rights reserved.
import os
from datetime import datetime, timezone

from jinja2 import Environment, FileSystemLoader, select_autoescape

from src.schemas.agents import (
    AggregateReport,
    ProspectProfile,
    ReportSummary,
    ROIPrediction,
    UserHistory,
)
from src.schemas.performance import SlippageAnalysis, TruthGapAnalysis


class AuditReportGenerator:
    """
    The 'Cash Generator': Turns raw database data and agent analysis into a
    professional PDF/JSON report that can be sold as a service.
    """

    # Initialize Jinja2 Environment
    _template_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "templates")
    _env = Environment(
        loader=FileSystemLoader(_template_dir),
        autoescape=select_autoescape(['html', 'xml'])
    )
    
    # Inject helpers
    _env.globals.update(now=lambda: datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC"))

    @staticmethod
    def generate_audit_summary(
        user: UserHistory,
        slippage: SlippageAnalysis,
        truth_gap: TruthGapAnalysis,
        commitments: list[str] | None = None,
        reality: str = "",
    ) -> ReportSummary:
        """
        Creates a high-value 'Performance Integrity Audit' for a manager.
        """
        return ReportSummary(
            report_id=f"AUDIT-{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}-{user.user_id}",
            generated_at=datetime.now(timezone.utc).isoformat(),
            subject={
                "user_id": user.user_id,
                "reliability_score": f"{user.reliability_score:.2f}%",
                "total_commitments": user.total_commitments,
                "department": user.department,
            },
            performance_metrics={
                "status": slippage.status,
                "fulfillment_ratio": f"{slippage.fulfillment_ratio * 100:.2f}%",
                "fulfillment_val": slippage.fulfillment_ratio,
                "detected_gap": slippage.detected_gap,
            },
            integrity_score={
                "aligned": not truth_gap.gap_detected,
                "truth_score": f"{truth_gap.truth_score * 100:.2f}%",
                "truth_val": truth_gap.truth_score,
                "explanation": truth_gap.explanation,
            },
            intervention_recommendation={
                "required": slippage.intervention_required or truth_gap.gap_detected,
                "tone": truth_gap.recommended_tone,
                "summary": "High risk of technical debt accumulation detected."
                if truth_gap.gap_detected
                else "Maintain current performance.",
            },
            commitments=commitments or [],
            reality=reality,
        )

    @staticmethod
    def generate_markdown_audit(report: ReportSummary) -> str:
        """
        Turns a ReportSummary into a professional Markdown document.
        """
        subject_id = report.subject.get("user_id", "Unknown")
        rel_score = report.subject.get("reliability_score", "0.00%")
        total_commits = report.subject.get("total_commitments", 0)
        
        status = report.performance_metrics.get("status", "UNKNOWN")
        fulfillment = report.performance_metrics.get("fulfillment_ratio", "0.00%")
        gaps = report.performance_metrics.get("detected_gap", "No data")
        
        aligned = report.integrity_score.get("aligned", False)
        truth_score = report.integrity_score.get("truth_score", "0.00%")
        explanation = report.integrity_score.get("explanation", "No explanation provided")
        
        req = report.intervention_recommendation.get("required", False)
        tone = report.intervention_recommendation.get("tone", "neutral")
        summary = report.intervention_recommendation.get("summary", "Maintain performance")

        return f"""# ðŸ›¡ï¸ Performance Integrity Audit: {subject_id}
**Report ID**: `{report.report_id}` | **Date**: {report.generated_at[:10]}

---

## ðŸ“Š Summary Scorecard
| Metric | Value |
| :--- | :--- |
| **Reliability Score** | **{rel_score}** |
| **Total Commitments** | {total_commits} |
| **Fulfillment Ratio** | {fulfillment} |
| **Integrity Alignment** | {"âœ… ALIGNED" if aligned else "âš ï¸ GAP DETECTED"} |

---

## ðŸ” Performance Deep-Dive
**Status**: `{status}`

### Commitment Fulfillment
The subject has demonstrated a **{fulfillment}** fulfillment rate.
**Detected Gaps**: {gaps}

### Truth-Gap Analysis
**Confidence Score**: {truth_score}
{explanation}

---

## ðŸ› ï¸ Management Strategy
**Intervention Required**: **{"YES" if req else "NO"}**
**Recommended Tone**: `{tone}`

### Manager Summary
{summary}

---
*Generated by CommitVigil Accountability Infrastructure*
"""

    @classmethod
    def generate_html_audit(cls, report: ReportSummary) -> str:
        """
        Creates a premium, glassmorphic HTML report using Jinja2 templates.
        """
        template = cls._env.get_template("user_audit.html")
        return template.render(report=report)

    @classmethod
    def generate_department_html_audit(cls, report: AggregateReport) -> str:
        """
        Generates a premium HTML 'Heatmap' for departments using Jinja2.
        """
        template = cls._env.get_template("department_audit.html")
        return template.render(report=report)

    @staticmethod
    def generate_departmental_audit(
        department: str, 
        members: list[UserHistory], 
        intervention_rate: float,
        calculated_avg: float | None = None,
        calculated_burnout: int | None = None,
        total_count: int | None = None
    ) -> AggregateReport:
        """
        Enterprise Feature: Aggregates performance data for 100+ user departments.
        Now supports pre-calculated stats for scalability.
        """
        if not members and calculated_avg is None:
            return AggregateReport(
                department=department,
                total_members=0,
                average_reliability_score=100.0,
                burnout_risk_count=0,
                top_performers=[],
                critical_risk_members=[],
                intervention_acceptance_rate=intervention_rate,
                strategy_recommendation="Initial Audit: No member data found for this department.",
            )

        avg_rel = calculated_avg if calculated_avg is not None else round(sum(m.reliability_score for m in members) / len(members), 2)
        burnout = calculated_burnout if calculated_burnout is not None else len([m for m in members if m.reliability_score < 70.0])
        total_m = total_count if total_count is not None else len(members)

        top_perf = [m.user_id for m in members if m.reliability_score >= 90.0][:5]
        critical = [m.user_id for m in members if m.reliability_score < 50.0][:5]

        # Tiered Departmental Strategy Logic
        if avg_rel >= 90 and burnout == 0:
            strategy = "Elite Team Performance: Focus on high-impact objectives and reward consistency."
        elif avg_rel >= 80:
            strategy = "Standard Performance: Baseline integrity maintained. Monitor minor slippage."
        elif avg_rel >= 60 or burnout > 0:
            strategy = "Corrective Action Required: Systemic burnout or process failure detected."
        else:
            strategy = "Critical Intervention: Reassess team workload and process integrity immediately."

        return AggregateReport(
            department=department,
            total_members=total_m,
            average_reliability_score=avg_rel,
            burnout_risk_count=burnout,
            top_performers=top_perf,
            critical_risk_members=critical,
            intervention_acceptance_rate=intervention_rate,
            strategy_recommendation=strategy,
        )

    @classmethod
    def generate_org_html_audit(cls, org_data: dict) -> str:
        """
        Highest Level Rendering: The C-Level 'God-View' HTML Report.
        """
        template = cls._env.get_template("org_audit.html")
        return template.render(org=org_data)

    @classmethod
    def generate_organizational_audit(
        cls, department_reports: list[AggregateReport]
    ) -> dict:
        """
        Highest Hierarchy Level: The Full Organization View.
        Aggregates all departments into a single 'God-View' for the CEO/CTO.
        """
        if not department_reports:
            return {"status": "error", "message": "No departmental data available."}

        total_members = sum(r.total_members for r in department_reports)
        avg_org_rel = round(
            sum(r.average_reliability_score for r in department_reports)
            / len(department_reports),
            2,
        )
        total_burnout = sum(r.burnout_risk_count for r in department_reports)

        # Tiered Recommendation Logic
        if avg_org_rel >= 90 and total_burnout == 0:
            rec = "Elite Performance: Maintain current velocity and reward high-performers."
        elif avg_org_rel >= 80:
            rec = "Stable Performance: Minor slippage detected. Monitor at-risk nodes."
        elif avg_org_rel >= 70 or total_burnout > 0:
            rec = "Moderate Risk: Targeted intervention required to prevent systemic burnout."
        else:
            rec = "Critical Status: Immediate structural intervention and headcount review required."

        return {
            "organization_reliability": f"{avg_org_rel}%",
            "total_engineering_headcount": total_members,
            "systemic_burnout_risk": total_burnout,
            "departmental_breakdown": [
                {
                    "name": r.department,
                    "score": r.average_reliability_score,
                    "risk_nodes": r.burnout_risk_count,
                }
                for r in department_reports
            ],
            "recommendation": rec,
        }

    @staticmethod
    def predict_roi(profile: ProspectProfile, avg_slippage_rate: float = 0.15) -> ROIPrediction:
        """
        Sales Intelligence: Calculates the financial ROI of implementing CommitVigil.
        Based on: Total Engineers * Avg Salary * Slippage Rate * Recovery Improvement.
        """
        from src.core.config import settings

        hourly_rate = profile.avg_developer_salary / settings.ROI_WORKING_HOURS_PER_YEAR
        lost_hours_per_year = settings.ROI_WORKING_HOURS_PER_YEAR * avg_slippage_rate * profile.team_size
        recovered_hours = lost_hours_per_year * settings.ROI_IMPROVEMENT_FACTOR
        annual_savings = recovered_hours * hourly_rate

        # Payback Period (Calculated against monthly subscription fee)
        payback = (settings.ROI_MONTHLY_FEE_USD * 12) / (annual_savings / 12) if annual_savings > 0 else 12.0

        return ROIPrediction(
            annual_savings_usd=round(annual_savings, 2),
            developer_hours_recovered=round(recovered_hours, 1),
            slippage_reduction_percent=round(avg_slippage_rate * settings.ROI_IMPROVEMENT_FACTOR * 100, 1),
            payback_period_months=round(payback, 1),
            calculation_basis=f"Based on a team of {profile.team_size} with {avg_slippage_rate*100}% baseline slippage."
        )

    @classmethod
    def generate_prospect_audit(cls, profile: ProspectProfile) -> dict:
        """
        Executive Prospecting: Synthesizes a mockup audit to wow potential customers.
        """
        from src.schemas.performance import SlippageStatus

        # 1. Predict ROI
        roi = cls.predict_roi(profile)

        # 2. Mockup fictional member audits based on drift_scenarios
        mock_audits = []
        for scenario in profile.drift_scenarios:
            mock_user = UserHistory(
                user_id=scenario["who"],
                reliability_score=72.5,
                department="unknown",
            )
            mock_slippage = SlippageAnalysis(
                status=SlippageStatus.SLIPPING,
                fulfillment_ratio=0.1,
                detected_gap=f"User promised '{scenario['promise']}' but reality check shows '{scenario['reality']}'.",
                risk_to_system_stability=0.7,
                intervention_required=True
            )
            mock_gap = TruthGapAnalysis(
                gap_detected=True,
                truth_score=0.2,
                explanation="Significant delta between verbal commitment and technical evidence.",
                recommended_tone="firm"
            )
            mock_audits.append(cls.generate_audit_summary(mock_user, mock_slippage, mock_gap))

        return {
            "prospect": profile.company_name,
            "target": profile.target_role,
            "roi_prediction": roi.model_dump(),
            "sample_interventions": mock_audits,
            "prospectus_summary": f"CommitVigil identified {roi.developer_hours_recovered} hours of recoverable technical debt for {profile.company_name}."
        }

