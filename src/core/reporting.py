# Copyright (c) 2026 CommitVigil AI. All rights reserved.
import os
from datetime import datetime, timezone

from jinja2 import Environment, FileSystemLoader, select_autoescape

from src.schemas.agents import (
    AggregateReport,
    ProspectProfile,
    ReportSummary,
    ROIPrediction,
    UserHistory,
)
from src.schemas.performance import SlippageAnalysis, TruthGapAnalysis


class AuditReportGenerator:
    """
    The 'Cash Generator': Turns raw database data and agent analysis into a
    professional PDF/JSON report that can be sold as a service.
    """

    # Initialize Jinja2 Environment
    _template_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "templates")
    _env = Environment(
        loader=FileSystemLoader(_template_dir),
        autoescape=select_autoescape(['html', 'xml'])
    )
    
    # Inject helpers
    _env.globals.update(now=lambda: datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC"))

    @staticmethod
    def generate_audit_summary(
        user: UserHistory,
        slippage: SlippageAnalysis,
        truth_gap: TruthGapAnalysis,
        commitments: list[str] | None = None,
        reality: str = "",
    ) -> ReportSummary:
        """
        Creates a high-value 'Performance Integrity Audit' for a manager.
        """
        return ReportSummary(
            report_id=f"AUDIT-{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}-{user.user_id}",
            generated_at=datetime.now(timezone.utc).isoformat(),
            subject={
                "user_id": user.user_id,
                "reliability_score": f"{user.reliability_score:.2f}%",
                "total_commitments": user.total_commitments,
                "department": user.department,
            },
            performance_metrics={
                "status": slippage.status,
                "fulfillment_ratio": f"{slippage.fulfillment_ratio * 100:.2f}%",
                "fulfillment_val": slippage.fulfillment_ratio,
                "detected_gap": slippage.detected_gap,
            },
            integrity_score={
                "aligned": not truth_gap.gap_detected,
                "truth_score": f"{truth_gap.truth_score * 100:.2f}%",
                "truth_val": truth_gap.truth_score,
                "explanation": truth_gap.explanation,
            },
            intervention_recommendation={
                "required": slippage.intervention_required or truth_gap.gap_detected,
                "tone": truth_gap.recommended_tone,
                "summary": "High risk of technical debt accumulation detected."
                if truth_gap.gap_detected
                else "Maintain current performance.",
            },
            commitments=commitments or [],
            reality=reality,
        )

    @staticmethod
    def generate_markdown_audit(report: ReportSummary) -> str:
        """
        Turns a ReportSummary into a professional Markdown document.
        """
        subject_id = report.subject.get("user_id", "Unknown")
        rel_score = report.subject.get("reliability_score", "0.00%")
        total_commits = report.subject.get("total_commitments", 0)
        
        status = report.performance_metrics.get("status", "UNKNOWN")
        fulfillment = report.performance_metrics.get("fulfillment_ratio", "0.00%")
        gaps = report.performance_metrics.get("detected_gap", "No data")
        
        aligned = report.integrity_score.get("aligned", False)
        truth_score = report.integrity_score.get("truth_score", "0.00%")
        explanation = report.integrity_score.get("explanation", "No explanation provided")
        
        req = report.intervention_recommendation.get("required", False)
        tone = report.intervention_recommendation.get("tone", "neutral")
        summary = report.intervention_recommendation.get("summary", "Maintain performance")

        return f"""# ðŸ›¡ï¸ Performance Integrity Audit: {subject_id}
**Report ID**: `{report.report_id}` | **Date**: {report.generated_at[:10]}

---

## ðŸ“Š Summary Scorecard
| Metric | Value |
| :--- | :--- |
| **Reliability Score** | **{rel_score}** |
| **Total Commitments** | {total_commits} |
| **Fulfillment Ratio** | {fulfillment} |
| **Integrity Alignment** | {"âœ… ALIGNED" if aligned else "âš ï¸ GAP DETECTED"} |

---

## ðŸ” Performance Deep-Dive
**Status**: `{status}`

### Commitment Fulfillment
The subject has demonstrated a **{fulfillment}** fulfillment rate.
**Detected Gaps**: {gaps}

### Truth-Gap Analysis
**Confidence Score**: {truth_score}
{explanation}

---

## ðŸ› ï¸ Management Strategy
**Intervention Required**: **{"YES" if req else "NO"}**
**Recommended Tone**: `{tone}`

### Manager Summary
{summary}

---
*Generated by CommitVigil Accountability Infrastructure*
"""

    @classmethod
    def generate_html_audit(cls, report: ReportSummary) -> str:
        """
        Creates a premium, glassmorphic HTML report using Jinja2 templates.
        """
        template = cls._env.get_template("user_audit.html")
        return template.render(report=report)

    @classmethod
    def render_landing_page(cls) -> str:
        """
        Renders the glassmorphic interactive landing page for sales demo use.
        """
        template = cls._env.get_template("landing_page.html")
        return template.render()

    @classmethod
    def generate_department_html_audit(cls, report: AggregateReport) -> str:
        """
        Generates a premium HTML 'Heatmap' for departments using Jinja2.
        """
        template = cls._env.get_template("department_audit.html")
        return template.render(report=report)

    @staticmethod
    def generate_departmental_audit(
        department: str, 
        members: list[UserHistory], 
        intervention_rate: float,
        calculated_avg: float | None = None,
        calculated_burnout: int | None = None,
        total_count: int | None = None
    ) -> AggregateReport:
        """
        Enterprise Feature: Aggregates performance data for 100+ user departments.
        Now supports pre-calculated stats for scalability.
        """
        if not members and calculated_avg is None:
            return AggregateReport(
                department=department,
                total_members=0,
                average_reliability_score=100.0,
                burnout_risk_count=0,
                top_performers=[],
                critical_risk_members=[],
                intervention_acceptance_rate=intervention_rate,
                strategy_recommendation="Initial Audit: No member data found for this department.",
            )

        avg_rel = calculated_avg if calculated_avg is not None else round(sum(m.reliability_score for m in members) / len(members), 2)
        burnout = calculated_burnout if calculated_burnout is not None else len([m for m in members if m.reliability_score < 70.0])
        total_m = total_count if total_count is not None else len(members)

        top_perf = [m.user_id for m in members if m.reliability_score >= 90.0][:5]
        critical = [m.user_id for m in members if m.reliability_score < 50.0][:5]

        # Tiered Departmental Strategy Logic
        if avg_rel >= 90 and burnout == 0:
            strategy = "Elite Team Performance: Focus on high-impact objectives and reward consistency."
        elif avg_rel >= 80:
            strategy = "Standard Performance: Baseline integrity maintained. Monitor minor slippage."
        elif avg_rel >= 60 or burnout > 0:
            strategy = "Corrective Action Required: Systemic burnout or process failure detected."
        else:
            strategy = "Critical Intervention: Reassess team workload and process integrity immediately."

        return AggregateReport(
            department=department,
            total_members=total_m,
            average_reliability_score=avg_rel,
            burnout_risk_count=burnout,
            top_performers=top_perf,
            critical_risk_members=critical,
            intervention_acceptance_rate=intervention_rate,
            strategy_recommendation=strategy,
        )

    @classmethod
    def generate_org_html_audit(cls, org_data: dict) -> str:
        """
        Highest Level Rendering: The C-Level 'God-View' HTML Report.
        """
        template = cls._env.get_template("org_audit.html")
        return template.render(org=org_data)

    @classmethod
    def generate_organizational_audit(
        cls, department_reports: list[AggregateReport]
    ) -> dict:
        """
        Highest Hierarchy Level: The Full Organization View.
        Aggregates all departments into a single 'God-View' for the CEO/CTO.
        """
        if not department_reports:
            return {"status": "error", "message": "No departmental data available."}

        total_members = sum(r.total_members for r in department_reports)
        avg_org_rel = round(
            sum(r.average_reliability_score for r in department_reports)
            / len(department_reports),
            2,
        )
        total_burnout = sum(r.burnout_risk_count for r in department_reports)

        # Tiered Recommendation Logic
        if avg_org_rel >= 90 and total_burnout == 0:
            rec = "Elite Performance: Maintain current velocity and reward high-performers."
        elif avg_org_rel >= 80:
            rec = "Stable Performance: Minor slippage detected. Monitor at-risk nodes."
        elif avg_org_rel >= 70 or total_burnout > 0:
            rec = "Moderate Risk: Targeted intervention required to prevent systemic burnout."
        else:
            rec = "Critical Status: Immediate structural intervention and headcount review required."

        return {
            "organization_reliability": f"{avg_org_rel}%",
            "total_engineering_headcount": total_members,
            "systemic_burnout_risk": total_burnout,
            "departmental_breakdown": [
                {
                    "name": r.department,
                    "score": r.average_reliability_score,
                    "risk_nodes": r.burnout_risk_count,
                }
                for r in department_reports
            ],
            "recommendation": rec,
        }

    @staticmethod
    def predict_roi(profile: ProspectProfile, currency: str = "USD") -> ROIPrediction:
        """
        Calculates projected ROI for a prospect based on their profile.
        Supports USD, EUR, GBP.
        """
        from src.core.config import settings
        # 1. Calculate Slippage Costs
        # Assumption: 15% of salary is lost to "Engagement Slippage" (Task switching, ambiguity, burnout)
        slippage_factor = 0.15
        
        # Handle Currency
        currency_map = {"USD": 1.0, "EUR": 0.92, "GBP": 0.78}
        rate = currency_map.get(currency.upper(), 1.0)
        
        # Normalize to USD for base calculation logic, then convert back
        yearly_cost_usd = (profile.avg_developer_salary / rate) * profile.team_size
        cost_of_slippage_usd = yearly_cost_usd * slippage_factor
        
        # 2. Predicted Savings (CommitVoid recovers 40% of slippage)
        recovery_rate = settings.ROI_IMPROVEMENT_FACTOR  # e.g., 0.40
        annual_savings_usd = cost_of_slippage_usd * recovery_rate
        
        # Convert savings back to requested currency for display-ready value in the object
        # Note: ROIPrediction schema officially has 'annual_savings_usd', but we will
        # interpret it as 'annual_savings_in_currency' for the API consumer if they requested non-USD.
        # Ideally, we should update the schema, but for Phase 6 GTM speed, we return the value.
        annual_savings_converted = annual_savings_usd * rate

        # 3. Efficiency Gains
        hours_per_dev = 2080 # 40hr week * 52
        total_hours_lost = (profile.team_size * hours_per_dev) * slippage_factor
        hours_recovered = total_hours_lost * recovery_rate
        
        # 4. Payback Period
        # Assume SaaS cost is ~1% of payroll or $500/dev/year
        licensing_cost = profile.team_size * 500
        payback_months = (licensing_cost / annual_savings_converted) * 12 if annual_savings_converted > 0 else 0

        return ROIPrediction(
            annual_savings_usd=annual_savings_converted,
            developer_hours_recovered=hours_recovered,
            slippage_reduction_percent=int(recovery_rate * 100),
            payback_period_months=round(payback_months, 1),
            calculation_basis=f"Based on {slippage_factor*100}% slippage and {recovery_rate*100}% recovery rate in {currency}."
        )

    @staticmethod
    def generate_sales_brief_html(profile: ProspectProfile, roi: ROIPrediction, currency: str = "USD") -> str:
        """
        Generates a premium HTML one-pager for Executive Sales Meetings.
        """
        symbol = "$" if currency == "USD" else "â‚¬" if currency == "EUR" else "Â£" if currency == "GBP" else currency
        
        scenarios_html = ""
        for s in profile.drift_scenarios:
            scenarios_html += f"""
            <div class="scenario-card">
                <div class="role-badge">{s['who']}</div>
                <div class="promise"><strong>Promise:</strong> "{s['promise']}"</div>
                <div class="reality"><strong>Reality:</strong> "{s['reality']}"</div>
            </div>
            """

        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Executive Brief: {profile.company_name}</title>
            <style>
                body {{ font-family: 'Inter', sans-serif; background: #0f172a; color: #e2e8f0; margin: 0; padding: 40px; }}
                .container {{ max-width: 800px; margin: 0 auto; background: #1e293b; padding: 40px; border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }}
                h1 {{ color: #38bdf8; border-bottom: 2px solid #334155; padding-bottom: 10px; }}
                h2 {{ color: #94a3b8; font-size: 1.2rem; margin-top: 30px; }}
                .stat-grid {{ display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }}
                .stat-box {{ background: #0f172a; padding: 20px; border-radius: 8px; border: 1px solid #334155; text-align: center; }}
                .stat-value {{ font-size: 2rem; font-weight: bold; color: #4ade80; }}
                .stat-label {{ color: #94a3b8; font-size: 0.9rem; margin-top: 5px; }}
                .scenario-card {{ background: #334155; padding: 15px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid #f87171; }}
                .role-badge {{ font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #cbd5e1; margin-bottom: 5px; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>Executive Brief: {profile.company_name}</h1>
                <p>Prepared for: <strong>{profile.target_role}</strong> | Industry: <strong>{profile.drift_scenarios[0]['who'] if profile.drift_scenarios else 'Generic'}</strong></p>
                
                <h2> projected Annual ROI ({currency})</h2>
                <div class="stat-grid">
                    <div class="stat-box">
                        <div class="stat-value">{symbol}{roi.annual_savings_usd:,.0f}</div>
                        <div class="stat-label">Annual Savings</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">{roi.slippage_reduction_percent}%</div>
                        <div class="stat-label">Efficiency Gain</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">{roi.payback_period_months} mo</div>
                        <div class="stat-label">Payback Period</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">{roi.developer_hours_recovered:,.0f}h</div>
                        <div class="stat-label">Hours Recovered</div>
                    </div>
                </div>

                <h2>ðŸš« Simulated Drift Vectors</h2>
                <p>Based on industry analysis, here is how commitments are currently slipping:</p>
                {scenarios_html}

                <div style="margin-top: 40px; text-align: center; color: #64748b; font-size: 0.9rem;">
                    Generated by CommitVigil Sales Intelligence â€¢ {roi.calculation_basis}
                </div>
            </div>
        </body>
        </html>
        """

    @classmethod
    def generate_prospect_audit(cls, profile: ProspectProfile) -> dict:
        """
        Executive Prospecting: Synthesizes a mockup audit to wow potential customers.
        """
        from src.schemas.performance import SlippageStatus

        # 1. Predict ROI
        roi = cls.predict_roi(profile)

        # 2. Mockup fictional member audits based on drift_scenarios
        mock_audits = []
        for scenario in profile.drift_scenarios:
            mock_user = UserHistory(
                user_id=scenario["who"],
                reliability_score=72.5,
                department="unknown",
            )
            mock_slippage = SlippageAnalysis(
                status=SlippageStatus.SLIPPING,
                fulfillment_ratio=0.1,
                detected_gap=f"User promised '{scenario['promise']}' but reality check shows '{scenario['reality']}'.",
                risk_to_system_stability=0.7,
                intervention_required=True
            )
            mock_gap = TruthGapAnalysis(
                gap_detected=True,
                truth_score=0.2,
                explanation="Significant delta between verbal commitment and technical evidence.",
                recommended_tone="firm"
            )
            mock_audits.append(cls.generate_audit_summary(mock_user, mock_slippage, mock_gap))

        return {
            "prospect": profile.company_name,
            "target": profile.target_role,
            "roi_prediction": roi.model_dump(),
            "sample_interventions": mock_audits,
            "prospectus_summary": f"CommitVigil identified {roi.developer_hours_recovered} hours of recoverable technical debt for {profile.company_name}."
        }

